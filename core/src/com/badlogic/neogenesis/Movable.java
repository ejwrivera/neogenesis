package com.badlogic.neogenesis;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Circle;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

public class Movable implements IMobile {

	/** The position. */
	protected Vector2 position;
	/** The ideal position. */
	private Vector2 movingTowards;
	/** The last movement, for momentum */
	public Vector2 lastMovement;
	/** The ai. */
	private AI AI;
	/** The hunting. */
	private boolean hunting;
	
	public Devourer inBellyOf;
	
	
	public Movable (Vector2 startPos, AI temp){
		this.position = startPos;
		lastMovement = new Vector2(0, 0);
		AI = temp;
	}
	
	@Override
	public void move() {
		// needs to be refactored; movement shouldn't have this kind of branching
		if (inBellyOf==null){
			// movingTowards should be set to a random nearby location if nothing is to be hunted, generated by AI; no branching
			if (hunting&&movingTowards!=null){
				Vector2 oldPosition = new Vector2(position.x, position.y);
				Vector2 movement = new Vector2(50 * Gdx.graphics.getDeltaTime(), 0);
				Vector2 temp = new Vector2(movingTowards);
				movement = movement.rotate(temp.sub(oldPosition).angle());
				Vector2 newPosition = new Vector2(oldPosition).add(movement);
				position.x = newPosition.x;
				position.y = newPosition.y;
				lastMovement = new Vector2(position.x-oldPosition.x, position.y-oldPosition.y);	
			}
			else{
				if (MathUtils.random(1,50)==50){
					lastMovement = AI.amble(getCircle());
					position.x+=lastMovement.x;
					position.y+=lastMovement.y;
				} else {
					lastMovement = AI.forage(getCircle());
					position.x+=lastMovement.x;
					position.y+=lastMovement.y;
				}
			}
		}
		else {
			Vector2 newPosition;
			Vector2 bellyCenter = inBellyOf.getCenter();
			Vector2 oldPosition = new Vector2(position.x, position.y);
			if (Math.abs(position.x-bellyCenter.x)+Math.abs(position.y-bellyCenter.y)<6){
				newPosition = bellyCenter;
			}
			else{
				Vector2 movement = new Vector2(320 * Gdx.graphics.getDeltaTime(), 0);
				// point towards center of inBellyOf
				
				movement = movement.rotate(bellyCenter.sub(oldPosition).angle());
				newPosition = new Vector2(oldPosition).add(movement);
			}
			position.x = newPosition.x;
			position.y = newPosition.y;
			lastMovement = new Vector2(position.x-oldPosition.x, position.y-oldPosition.y);
		}
	}
	
	public void setMovingTowards(Vector2 idealPosition){
		movingTowards = idealPosition;
	}
	
	private Circle circle;
	
	private Circle getCircle (){ return circle; }
	
	public void setCircle(Circle circle){
		this.circle = circle;
	}
	
	public void setHunting (boolean hunting){
		this.hunting = hunting;
	}
	
	public Vector2 getPosition(){
		return position;
	}
	
	
}
