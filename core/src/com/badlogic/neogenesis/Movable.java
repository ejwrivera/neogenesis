package com.badlogic.neogenesis;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Circle;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

public class Movable implements IMobile {

	/** The position. */
	protected Vector2 position;
	/** The ideal position. */
	private Vector2 movingTowards;
	/** The last movement, for momentum */
	public Vector2 velocity;
	/** The ai. */
	private AI AI;
	/** The hunting. */
	private boolean hunting;
	
	public Devourer inBellyOf;
	
	public Array<Vector2> forces;
	
	public Movable (Vector2 startPos, AI temp){
		this.position = startPos;
		velocity = new Vector2(0, 0);
		AI = temp;
		forces = new Array<Vector2>();
	}
	
	@Override
	public void move() {
		// needs to be refactored; movement shouldn't have this kind of branching
		if (inBellyOf==null){
			// movingTowards should be set to a random nearby location if nothing is to be hunted, generated by AI; no branching
			if (hunting&&movingTowards!=null){
				Vector2 oldPosition = new Vector2(position.x, position.y);
				Vector2 movement = new Vector2(50 * Gdx.graphics.getDeltaTime(), 0);
				Vector2 temp = new Vector2(movingTowards);
				movement = movement.rotate(temp.sub(oldPosition).angle());
				forces.add(movement);
				//Vector2 newPosition = new Vector2(oldPosition).add(movement);
				//position.x = newPosition.x;
				//position.y = newPosition.y;
				//velocity = new Vector2(position.x-oldPosition.x, position.y-oldPosition.y);	
			}
			else{
				Vector2 amble;
				if (MathUtils.random(1,50)==50){
					amble = AI.amble(getCircle());
					//position.x+=velocity.x;
					//position.y+=velocity.y;
				} else {
					amble = AI.forage(getCircle());
					//position.x+=velocity.x;
					//position.y+=velocity.y;
				}
				forces.add(amble);
			}
		}
		else {
			// Vector2 newPosition;
			Vector2 bellyCenter = inBellyOf.getCenter();
			Vector2 oldPosition = new Vector2(position.x, position.y);
			if (Math.abs(position.x-bellyCenter.x)+Math.abs(position.y-bellyCenter.y)<6){
				//newPosition = bellyCenter;
				position = bellyCenter;
			}
			else{
				Vector2 movement = new Vector2(320 * Gdx.graphics.getDeltaTime(), 0);
				// point towards center of inBellyOf
				
				movement = movement.rotate(bellyCenter.sub(oldPosition).angle());
				forces.add(movement);
				//newPosition = new Vector2(oldPosition).add(movement);
			}
			//position.x = newPosition.x;
			//position.y = newPosition.y;
			//velocity = new Vector2(position.x-oldPosition.x, position.y-oldPosition.y);
		}
		
		velocity = new Vector2(velocity.x / 2, velocity.y / 2);
		
		for (Vector2 force: forces){
			velocity.add(force);
		}
		position.add(velocity);
		forces.clear();
	}
	
	public void setMovingTowards(Vector2 idealPosition){
		movingTowards = idealPosition;
	}
	
	private Circle circle;
	
	private Circle getCircle (){ return circle; }
	
	public void setCircle(Circle circle){
		this.circle = circle;
	}
	
	public void setHunting (boolean hunting){
		this.hunting = hunting;
	}
	
	public Vector2 getPosition(){
		return position;
	}

	@Override
	public void addForce(Vector2 force) {
		forces.add(force);
	}
	
	
}
